Версия 19.02.11
Peaлизовано:
        - подключение gnuplot (тестовое) в классы PR_Task и Task добавлены ::plot()
                - дистрибутив http://www.gnuplot.info/download.html
                - библиотека https://github.com/dstahlke/gnuplot-iostream , http://www.stahlke.org/dan/gnuplot-iostream/
                - настройка (прописать PATH) https://github.com/dstahlke/gnuplot-iostream/wiki/Portability
                - требуется дополнительно
                        -- установка boost
                        -- переключение на компилятор CLANG

Версия 08.02.11
Peaлизовано:
        - все индексы переведены в unsigned long или unsigned int типы
        - почищены  warnings компилятора (36)
        - избавиться от глобальных констант - введён соотв. статический singleton
Исправлено:
        - исправлена ошибка в
                void Task::Control_AltInt(int trNum)
                void Task::Control_Puntryagin(int trNum)
                void Task::Control_R1(int trNum)
                void Task::Control_R2(int trNum)
          неправильный расчёт индекса по основному циклу
        - исправлена ошибка в расчёте хода времени в методах
                void PR_Task::Control_PR(int trNum)
                void PR_Task::Control_PR_fullSets(int trNum)
          некорректное условие расчёта при оценке не прошли ли верхнюю границу множества управляемости
        - вывод времени в файл в задачах уклонения


Версия 01.02.11
Исправлено:
        - некорректная разметка индекса, отмечающего выпуклость мн-ва. массив L_i метод makeAlpha
        - прогнано через статистический анализатор (0/6/68/0/4/0) - разумные исправлениея внесены

Версия 16.01.11
Реализовано:
        - загрузка нового типа файлов задач для решения задач убегания, формат
        [оп. ф-я терм. мн-ва, оп. ф-я  мн-ва помехи, {вектора центров терм. мн-в преследователей}]
        и соотв. тип задачи убегания
        Загрузка сначала производится в класс pursuerType - тип преследователя,
        потом, для каждого преследователя строится соотв  класс Pursuer и множество
        funnel "воронка", избегание которого гарантирует успешное разрешение задачи
        наведения
        - расчёт максимального радиуса множества, необходимо для того, чтобы не
        сравнивать на каждом шаге позицию системы со всеми множествами, зависящими от "помех",
        ограничиваясь только теми, до которых "можно долететь" на следующем шаге

Исправлено:
        - проверка множества задаваемого опорной функцией на пустоту - реализовано
        через свойство TNetF.is_empty

Надо сделать
        - оптимизацию расчёта множества funnel т.к. в приципе нет необходимости каждый
        раз пересчитывать слагаемые для альтернированного интеграла
        -разобраться в чём проблема при малом размере терминального мн-ва помехи
        - PR_Task::Control_PR_fullSets и PR_Task::Control_PR - переработать условия
        выхода из цикла while(true)
        - провести тестирование, идентифицировать и исправить ошибки
        - добавить новый метод овыпукления
        - сделать вывод графики
        - исправить работу с ini файлами
        + прогнать через статистический анализатор (3/81/183/0/21/0)
        + избавиться от глобальных констант
        - почистить warnings компилятора (247)
        - написать статьи и обсудить их с НГ
        - параметр annealing в загрузке сделать зависимым от трёх параметров (параметры метода)


