Решение линейных дифференциальных игр
-------------------------------------------------------------------------------
Как ставить
Пререквизиты
1. Бесплатная редакция Embarcadero С++ Builder (иногда можно получить лицензию)
2. SICx  - Компилятор математических выражений (x86 & x64, DLL) (http://maalchemist.narod.ru/)
3. GnuPlot (http://gnuplot.info/, https://sourceforge.net/projects/gnuplot/files/gnuplot/)

Настройка
1. Установить все компоененты
2. Развернуть проект
3. В настроки проекта Project->Options->Debugger->Environment Block добавить переменную
        DC_PATH c значением пути к директории проекта
4. Аналогичную переменную (DC_PATH) можно завести в системном окружении для запуска вне среды  С++ Builder
5. Скопировать DLL SICx в папку к dc_res.exe

--------------------------------------------------------------------------------
Настройки:
data/dconsole.ini - глобальные настройки метода отжига
        extr_e_param - степень e при понижении "температуры" - должна быть <0
        extr_t0_param - начальная "температура"
        extr_tmin_param - конечная температура

data/control.ini - перечень задач к решению с указанием методов решения и их настроек
        file - имя файла задачи *.inp
        type -  тип задачи pursue_run(наведение + уклонение ограничений) |
                pursue (обычная ДИ)
        method - метод решения задачи
                для типа pursue
                        pontryagin - первый метод предследования Л.С.Понтрягина
                        alt_int - альтернированный инетграл
                        gr1|gr2 - решение задачи приследования в уссловиях нехватки информации
                для типа pursue_run
                        full_sets (наведение-уклонение обычный)
                        full_sets_smooth (уменьшение кол-ва переключений)
        search_optimisation - оптимизация процедур поиска по сетке
                none - простой перебор
                annealing - метод отжига
                gradient - градиентный спуск (только для выпуклых множеств)
                TimS - с использованием особенностей геом. разности (пока в отладке)
        v_control - правило поведения противника (отключено, сейчас всегда наилучший ответ либо константа)
                optimal - наилучший ответ
                random - случайное поведение
                const - постоянное управление
        result - имя файла результата *.res


data/*.inp - описание задач  (соблюдение порядка тегов важно, формат важен)
        (Method)  -   Код метода (0-преследование, 1 - преследование-убегание)
        (Description) - описание задачи
        (Priority) - приоритет вычисления задач (отключено)
        (Level)  - степень готовности расчётов (отключено)
        (t0) - начальное время
        (x0,4,1) - вектор начального состояния и его размерность
        (A,4,4) - матрица A и её размерность
        (B,4,2) - матрица B и её размерность
        (C,4,2) - матрица C и её размерность
        (PP,2,4)- матрица Pi и её размерность
        (epsilon) - параметр эпсилон-окресности терминального множества
        (precision) - парамер точности для дазличных численных методов
        (tau) - шаг по времени
        (maxTime) - максимальное время вычислений
        (dim_x) - размерность вектора x - должна совпадать с соотв. размерностями матриц
        (dim_u) - размерность вектора u - управления первого игрока - должна совпадать с соотв. размерностями матриц
        (dim_v) - размерность вектора v - управления второго игрока - должна совпадать с соотв. размерностями матриц
        (dim_m) - разменость "нецилиндрической" части терминально множества
        (dim_m1) - резерв
        (steps) -  кол-во узлоа на одномерном ребре сетки
        (perfomance) - (0-4) параметр прозводительности - регулирует частоу использования градинетного методв
        (fP) - опорная функция множества возможностей первого игрока
        (fQ) - опорная функция множества возможностей первого игрока
        (fM) - опорная функция  терминального множества
        (fN1) - параметры множества помехи  (для задач преследования убегания)
                m - опорная функция мн-ва помехи
                v - опорная функция мн-ва возможностей второго игрока управляющего мн-вом помехи
                []; []; - точки "привязки" множеств помехи
--------------------------------------------------------------------------------
Надо сделать:
        - оптимизацию расчёта множества funnel т.к. в приципе нет необходимости
          каждый раз пересчитывать слагаемые для альтернированного интеграла
        - разобраться в чём проблема при малом размере терминального мн-ва
          помехи
        - PR_Task::Control_PR_fullSets и PR_Task::Control_PR - переработать
          условия выхода из цикла while(true)
        -/+ провести тестирование, идентифицировать и исправить ошибки
        -/+ добавить новый метод овыпукления
        +/- сделать вывод графики (множества и проверку <3D)
        - исправить работу с ini файлами  (некоторые символы подменяются другой
          кодировкой)
        - написать статьи и обсудить их с НГ
        - параметр annealing в загрузке сделать зависимым от трёх параметров
          (параметры метода)
        - сделать оператор Vector::oretator[](long) нормальным т.к. сейчас в
          Netfunc f[i] работает только в качестве lvalue, а для rvalue надо
          (*f)[i]
        - проверить Net::parseCoordinate на зацикливание


--------------------------------------------------------------------------------
Версия 05.11.17

Исправлено:
        - доработано под компилятор CLang x64
        - проверено CPPCheck - внесены исправления по итогам проверки
		(проект CPPCheck прикладываю diss.cppcheck)
--------------------------------------------------------------------------------
Версия 27.05.17

Исправлено:
        - warnings в методах WriteLn и Report в CDataFile
        - прочие мелкие ошибки
--------------------------------------------------------------------------------
Версия 12.03.17

Исправлено:
        - ошибки в методах Control_PR_fullSets_smooth,  процедура сглаживания, есть ощущение, что не до конца, но тем не менее работает
        - ошибка в TaskLoader::load_and_calc_tasks() - программа закрывается, а не зависает при ненахождении файла

 --------------------------------------------------------------------------------
Версия 25.02.17

Peaлизовано:
        -  в методах Control_PR_fullSets_smooth, recusionStep протестировано сглаживание для случая когда наведение сменяется уклонением
        -  в методах Control_PR_fullSets_smooth, recusionStep частично работет случай сглаживания когда наведение после сглаживания сменяется наведением
Исправлено:
        - ошибки в методах Control_PR_fullSets_smooth, recusionStep, учтено измельчение шага на случай если "отскок" оказывается рядом с начальной точкой

 --------------------------------------------------------------------------------
Версия 15.02.17

Peaлизовано:
        - рефакторинг методов класса PR_Task: public Task для облегчения читабельности кода


--------------------------------------------------------------------------------
Версия 14.02.17

Peaлизовано:
        - доработано taskLoader::load_and_calc_tasks() для расчёта новым методом  "full_sets_smooth"
        сглаженное экстремальное управление и "full_sets"-обычное экстремальное прицеливание

--------------------------------------------------------------------------------
Версия 14.02.17  (beta)

Peaлизовано:
        - метод Control_PR_fullSets_smooth - для расчёта сглаженного управления экстремальным способом как
        friend к классу PR_Task
Исправлено:
        - комментарии по коду


--------------------------------------------------------------------------------
Версия 06.08.16

Peaлизовано:
        - метод factorial для расчёта i!
        - методы Vector.one(), Vector.zero() для единичных и нулевых векторов
        - метод pinMark() для 2D
Исправлено:
        - ошибки  рамок определения переменных _mod,__mod и coordNumber в классе Net
        - убраны некоторые предупреждения компилятора
        - Net::shift()
        - неверная простановка метки при переходе на новую грань borderChanged

--------------------------------------------------------------------------------
Версия 02.03.16

Peaлизовано:
        - добавлен простой класс двумерного динамического массива t_Mx
Исправлено:
        - ошибки определения размера типа LDouble в
                sMx::sMx(sMx &C)
                sVec::sVec(const LDouble *vv, unsigned long sz)
                sMx::create()
        - во всех вхождениях "float" и "double" заменены на единый тип LDouble
          определяемый в general.h, что минимизирует проблемы с адресной
          арифметикой

--------------------------------------------------------------------------------
Версия 01.03.16

Peaлизовано:
        - добавлен метод овыпукления TNetF::ConvTimS - требует тестирования
        - переименованы файлы проекта на приличные
        - подключена библиотека Unit тестов и добавлен соотв. проект dc_res_test
Исправлено:
        - ошибка TNetF::Conv - неверный вектор для проверки условия максимума
        - ошибка TNetF::Conv - неверное условиие поиска максимума для постоения
          опорной функции по L[j]
Открытая ошибка:
        - в методе Task::Control_R2 - иногда неверно восстанавливаеся управление
          преследователя

--------------------------------------------------------------------------------
Версия 19.02.16
Peaлизовано:
        - подключение gnuplot (тестовое) в классы PR_Task и Task добавлены ::plot()
                - дистрибутив http://www.gnuplot.info/download.html
                - библиотека https://github.com/dstahlke/gnuplot-iostream , http://www.stahlke.org/dan/gnuplot-iostream/
                - настройка (прописать PATH) https://github.com/dstahlke/gnuplot-iostream/wiki/Portability
                - требуется дополнительно
                        -- установка boost
                        -- переключение на компилятор CLANG

--------------------------------------------------------------------------------
Версия 08.02.16
Peaлизовано:
        - все индексы переведены в unsigned long или unsigned int типы
        - почищены  warnings компилятора (36)
        - избавиться от глобальных констант - введён соотв. статический singleton
Исправлено:
        - исправлена ошибка в
                void Task::Control_AltInt(int trNum)
                void Task::Control_Puntryagin(int trNum)
                void Task::Control_R1(int trNum)
                void Task::Control_R2(int trNum)
          неправильный расчёт индекса по основному циклу
        - исправлена ошибка в расчёте хода времени в методах
                void PR_Task::Control_PR(int trNum)
                void PR_Task::Control_PR_fullSets(int trNum)
          некорректное условие расчёта при оценке не прошли ли верхнюю границу множества управляемости
        - вывод времени в файл в задачах уклонения

--------------------------------------------------------------------------------
Версия 01.02.16
Исправлено:
        - некорректная разметка индекса, отмечающего выпуклость мн-ва. массив L_i метод makeAlpha
        - прогнано через статистический анализатор (0/6/68/0/4/0) - разумные исправлениея внесены

Версия 16.01.16
Реализовано:
        - загрузка нового типа файлов задач для решения задач убегания, формат
        [оп. ф-я терм. мн-ва, оп. ф-я  мн-ва помехи, {вектора центров терм. мн-в преследователей}]
        и соотв. тип задачи убегания
        Загрузка сначала производится в класс pursuerType - тип преследователя,
        потом, для каждого преследователя строится соотв  класс Pursuer и множество
        funnel "воронка", избегание которого гарантирует успешное разрешение задачи
        наведения
        - расчёт максимального радиуса множества, необходимо для того, чтобы не
        сравнивать на каждом шаге позицию системы со всеми множествами, зависящими от "помех",
        ограничиваясь только теми, до которых "можно долететь" на следующем шаге

Исправлено:
        - проверка множества задаваемого опорной функцией на пустоту - реализовано
        через свойство TNetF.is_empty

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Сделано
        + прогнать через статистический анализатор (3/81/183/0/21/0)
        + избавиться от глобальных констант
        + почистить warnings компилятора (247)
        + в методе Task::Control_R2 - иногда неверно восстанавливаеся управление
          преследователя

